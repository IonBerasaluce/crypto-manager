

'''
This class is responsible of updating the positioning csv data files on a day to day basis as well as processing 
any data requests coming from the app. Updating the databases will be handled by exporting a json with the main 
information. Can do this in 2 ways:
    1. Reactive to events - not 100% sure how we can do this? Perhaps with wwebhooks but I doubt that works with private 
    data
    2. Windows task manager triggers at a sepcific time

Can the JSON file (data_manager_setup.json) be generated by the UI? Should it be?? - seems like a great way to solve
the issue of my_coins. 


'''

import json
import datetime as dt
import pandas as pd
import os

from exchange_manager import ExchangeManager
from config import SETUP_PATH
from utils import readCSV

class DBException(Exception):

    def __init__(self, *args: object) -> None:
        super().__init__(*args)()


# Need to rethink the way these requests are working and the best way to manage 
class DBRequest(object):
    def __init__(self, asset=None, start_time=None, end_time=None):
        self.asset = asset
        self.start_time = pd.to_datetime(start_time)
        self.end_time = pd.to_datetime(end_time)
        self.db_directory = 'data/'

    def toDict(self):
        return_dict = {}
        for k,v in self.__dict__.iteritems():
            if v == None:
                continue
            else:
                return_dict.update({k:v})

    def processRequest(self, db):

        try:
            df = readCSV(db)        
            if self.asset == None:
                req = df.loc[self.start_time:self.end_time, :]
            else:
                req = df.loc[df['asset'] == self.asset].loc[self.start_time:self.end_time]
        
            return req
        
        except Exception as e:
            print(e)
            return pd.DataFrame()
    
    def getTrades(self):
        db = self.db_directory + 'historical_trades.csv'
        return self.processRequest(db)

    def getDeposits(self):
        db = self.db_directory + 'historical_deposits.csv'
        return self.processRequest(db)

    def getWithdrawals(self):
        db = self.db_directory + 'historical_withdrawals.csv'
        return self.processRequest(db)

    def getDividends(self):
        db = self.db_directory + 'historical_dividends.csv'
        return self.processRequest(db)

    def getFiatActivities(self):
        db = self.db_directory + 'historical_fiat_movements.csv'
        return self.processRequest(db)

    def getDustActivities(self):
        db = self.db_directory + 'historical_dust_activities.csv'
        return self.processRequest(db)

    def getAccountMovements(self):
        db = self.db_directory + 'account_movements.csv'
        return self.processRequest(db)

class PositioningDataManager(object):
    def __init__(self):
        
        with open(SETUP_PATH) as infile:
            setup = json.load(infile)
        self.__dict__.update(setup)
        
        self.exchange_manager = ExchangeManager(self.my_coins, self.db_dir)

        # Updating the local dbs
        self.genDBs()

    def closeManager(self):
        with open(SETUP_PATH, "w") as outfile:
            json.dump(outfile)

    def genDBs(self):
       
       # This method will not be required when moving to an actual database
        try:
            for db in  os.listdir(self.db_dir):
                if readCSV(self.db_dir + db).empty:
                    if db == 'account_movements.csv':
                        continue
                    else:
                        self.exchange_manager.updateDBs(db, None, None)
            
            if readCSV(self.db_dir + 'account_movements.csv').empty:
                self.updateMovements(None, None)    

            return
        
        except Exception as e:
            print(e)
            raise(e)

    def updateDB(self):
        start_date = dt.datetime.strptime(self.last_update_date, '%Y-%m-%d %H:%M:%S')
        end_date = dt.datetime.now()

        if start_date == end_date:
            print('DB up to date')
            return 
        else:
            for db in os.listdir(self.db_dir):
                
                if db == 'account_movements.csv':
                    continue
                else:
                    self.exchange_manager.updateDBs(db, start_date, end_date)
            
            self.updateMovements()
            self.last_update_date = start_date
        
        return
    
    def updateMovements(self, start_time, end_time):
        full_db_dir = self.db_dir + 'account_movements.csv'
        fields = ['asset', 'amount', 'time', 'description']
        
        trades = self.getTrades(start_time, end_time).reindex(fields, axis=1)
        deposits = self.getDeposits(start_time, end_time).reindex(fields, axis=1)
        fiat = self.getFiat(start_time, end_time).reindex(fields, axis=1)
        withdrawals = self.getWithdrawals(start_time, end_time).reindex(fields, axis=1)
        dust = self.getDust(start_time, end_time).reindex(fields, axis=1)
        dividends = self.getDividends(start_time, end_time).reindex(fields, axis=1)
        
        db = readCSV(full_db_dir)
        db = pd.concat([db, trades, deposits, fiat, withdrawals, dust, dividends], axis=0, sort=False).sort_index()
        db.to_csv(full_db_dir)

    def getTrades(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getTrades()
        return request

    def getDeposits(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getDeposits()
        return request

    def getWithdrawals(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getWithdrawals()
        return request

    def getDividends(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getDividends()
        return request

    def getFiat(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getFiatActivities()
        return request
    
    def getDust(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getDustActivities()
        return request

    def getAccountMovements(self, start_time, end_time, asset=None):
        request = DBRequest(asset, start_time, end_time).getAccountMovements()
        return request


    